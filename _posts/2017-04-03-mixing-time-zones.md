---
layout: post
title: "Remember The Time"
date: 2017-04-03
---

I encountered a bug a week or so ago in an enterprise product which handles the
replication of NoSQL datastores. It was an annoying but humorous one, so I
thought I'd share it. Perhaps it might save someone the headache one day, or give
them a laugh / grimace.

The funny side of this bug is down to the timing - it only occurs in the lost
hour encountered when shifting the clocks forward for Daylight Savings Time
(DST). Once that hour (the one that doesn't really exist) has elapsed, everything goes
back to normal. So that makes it really useful in trying to pin down.

Luckily for me, I was the designated on-call that morning, so gladly fielded the
problem shortly after the clock struck 1AM... Or 2AM taking into account the
special hour. FML, right?

The reason for this behaviour is two-fold. Firstly, the enterprise software that
handles the multi-datacentre replication, for some reason, mixes functions which
handle DST timestamps with functions that exclusively handle UTC timestamps
(awesome!). The problem this creates is that there's a magical hour in UTC (Sunday, 26th
Match 01:00AM) that does not exist in DST, as it is skipped.

The second part of the problem is that in the Erlang/OTP httpd_util module has a
date formatting function - rfc1123_date/1 - which tries to convert a given
timestamp to a UTC datetime using the calendar:local_time_to_universal_time_dst/1
function. It expects the timestamp that your passing in to be a local timestamp,
and if it isn't, it does nothing about it. Great!

As far as I can see, the documentation doesn't actually indicate that this
function expects a local timestamp, so in that respect, I guess whoever is mixing
DST and UTC timestamps must not have been aware.

What is pretty unhelpful, though, is the lack of documentation, which is only compounded by the
non-existent validation. You pass in a timestamp that is not DST-aware, like a UTC
timestamp between 1AM and 2AM on Sunday, March 2017, and you've got a problem on
your hands. I think the actual timestamp was being generated by the
gregorian_seconds_to_date/1 function, which returns a UTC timestamp.

To fix the problem is trivial. You simply convert the timestamp to a local
timestamp which takes into account the magical hour. Ultimately, though, the
documentation in OTP seems to be a little confusing, and the
local_time_to_universal_time_dst/1 function returns an empty list when the input
time is not what it is expecting - which isn't handled by the calling function -
rfc1123_date/1. That sounds a little buggy to me.

Point is, time is a pig, moreso when accounting for differing timezones and
DST. And even moreso when trying to debug some edge-case at 2AM with broken
replication monitoring. 

Until next time... Whayyyyyy. ;)
Damn you, time!
